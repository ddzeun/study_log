## 벌크 연산

**벌크 연산**: **여러 건의 데이터를 한 번의 SQL 쿼리로 수정하거나 삭제**하는 방식

일반적으로 JPA의 `repository.delete(entity)`는 한 번에 하나의 엔티티만 삭제\
→ 만약 메시지 1,000개를 지워야 한다면, 이 작업은 사실상 1,000번의 `DELETE` 쿼리를 수행하는 것ㅘ 비슷하여 매우 비효율적

벌크 연산을 사용하면 단 한 번의 `DELETE` 쿼리로 이 모든 작업을 끝낼 수 있다


## @Modifying 어노테이션의 역할


- Spring Data JPA에게 **"이 쿼리는 조회용이 아니라 데이터를 직접 수정하거나 삭제하는 거"**라고 알려주기 위한 어노테이션

즉, `@Modifying`을 붙여주면 Spring Data JPA는 이 쿼리가 `executeUpdate()` 방식으로 실행되어야 한다는 것을 인지하고, 데이터를 변경하는 작업을 정상적으로 수행.\
만약 이 어노테이션을 빼먹고 `DELETE` 쿼리를 실행하면 예외 발생.

> `@Query`는 '읽기 전용' 모드, `@Modifying`은 '쓰기 모드'로 전환


## 벌크 연산의 중요한 주의점

`@Modifying`만 붙이면 다 알아서 작동하지만, **'영속성 컨텍스트(Persistence Context)'** 문제에 주의

  * **벌크 연산의 특징**: 벌크 연산은 영속성 컨텍스트를 거치지 않고, 데이터베이스에 직접 SQL 쿼리를 실행.
  * **문제점**: 이 때문에 영속성 컨텍스트(1차 캐시)에 남아있는 엔티티의 정보와 데이터베이스의 실제 데이터가 서로 달라지는 **데이터 불일치**가 발생할 수 있음.
  * **해결책**: `@Modifying(clearAutomatically = true)` 옵션을 사용하면, 해당 쿼리 실행 직후 영속성 컨텍스트를 **깨끗하게 비워줘서(clear)** 데이터 불일치 문제를 방지할 수 있어.

채팅방 삭제 기능처럼, 벌크 연산 이후에 다른 작업을 바로 하지 않는다면 큰 문제가 없을 수도 있지만, 데이터 정합성을 위해 `clearAutomatically = true` 옵션을 붙여주면 좋다