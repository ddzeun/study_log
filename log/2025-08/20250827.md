# WebSocket과 Spring Security

## 문제 발생
 
### 1. 인증 실패
- Spring Security의 필터 체인은 HTTP 프로토콜 기반으로 동작\
 -> 이 때문에 WebSocket(ws-stomp) 연결이 수립된 후 주고받는 STOMP 메시지들은 이 필터를 통과하지 않아, 요청이 처리 안됨

### 2. 사용자 뒤섞임
- 메시지를 처리할 때마다 인증 정보를 SecurityContextHolder에서 가져왔는데 WebSocket은 제한된 스레드를 여러 사용자가 공유하는 환경으로,\
**ThreadLocal** 기반의 SecurityContextHolder에 남아있던 이전 사용자의 정보가 스레드 재사용 시 다른 사용자에게 잘못 적용되는 동시성 이슈가 발생

```Java
@Override
public void configureClientInboundChannel(ChannelRegistration registration) {
    registration.interceptors(new ChannelInterceptor() {
        @Override
        public Message<?> preSend(Message<?> message, MessageChannel channel) {
            StompHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class);

            if (accessor != null && StompCommand.CONNECT.equals(accessor.getCommand())) {
                String jwtToken = accessor.getFirstNativeHeader("Authorization");
                // ... 토큰 검증 로직 ...

                if (jwtToken != null && jwtTokenProvider.validateToken(jwtToken)) {
                    Authentication authentication = jwtTokenProvider.getAuthenticationFromToken(jwtToken);
                    // WebSocket 세션에 직접 인증 정보를 저장
                    accessor.getSessionAttributes().put("userAuthentication", authentication);
                }
            }
            return message;
        }
    });
}
```

* SecurityContextHolder와 같이 상태를 가지는(Stateful) 방식 대신, 메시지 단위로 인증 정보를 처리하는 상태 없는(Stateless) 방식으로 전환

* CONNECT 시 사용자 설정: ChannelInterceptor에서 최초 연결 시에만 토큰을 검증하고, Authentication 객체를 accessor.setUser(authentication)를 통해 STOMP 세션 자체에 사용자를 설정.

* Principal 객체 주입: 컨트롤러의 @MessageMapping 메서드 파라미터를 Claims에서 Principal로 변경.\
매번 메시지를 처리할 때마다 해당 메시지를 보낸 사용자의 정보를 자동으로 주입해주도록 하여, 스레드 상태와 무관하게 정확한 사용자 식별이 가능