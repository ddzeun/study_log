# WebSocket 환경에서 JWT 인증

HTTP와 WebSocket은 근본적인 차이를 가지고 있음

### 1. Spring Security는 WebSocket의 메시지를 모름
 WebSocket은 HTTP와는 다른 프로토콜

- HTTP: 클라이언트가 요청을 보내면, 서버는 응답하고 연결을 끊는다. 모든 요청이 독립적인 단발성 이벤트로 Spring Security 필터는 이 단발성 요청들을 하나하나 검문하는 역할

- WebSocket: 최초 연결 시에만 HTTP를 사용해 Handshake 설정. 그 후엔 서버와 클라이언트 간에 하나의 연결 통로(Session)가 계속 유지됩니다.

### 문제 발생
- Spring Security 필터는 HTTP 요청을 검사할 뿐, 한번 뚫린 WebSocket 통로 안에서 오가는 메시지들까지는 신경 쓰지 않음.
- 연결이 수립된 후 보내는 채팅 메시지들은 JWT 인증을 모두 우회해버리는 것입니다.

### 해결 방안
- ChannelInterceptor를 사용해 WebSocket으로 들어오는 메시지 관문 자체를 가로채기
- 특히 최초 연결(CONNECT) 시점에 헤더에서 JWT를 직접 꺼내 수동으로 검증하는 로직이 필요

### 2. '상태 없음(Stateless)'과 '상태 있음(Stateful)'의 충돌

JWT는 Stateless, WebSocket은 Stateful한 상반된 특징을 가짐

- JWT (Stateless): 서버가 클라이언트를 기억할 필요 없이, 매번 요청에 포함된 JWT만 보고 신원을 확인

- WebSocket (Stateful): 서버와 클라이언트 간 연결이 계속 유지되므로, "A 유저가 접속 중"이라는 상태를 서버가 계속 알고 있음

### 문제 발생

- Stateless한 JWT 인증 방식을 Stateful한 WebSocket 환경에 어떻게 적용할 것인지, 두 상반된 패러다임이 충돌하는 문제가 발생

### 해결 방안

두 패러다임의 장점을 모두 취하는 방식으로 해결

- 인증은 Stateless하게: 최초 연결 시에만 JWT로 신원을 확인

- 연결은 Stateful하게: 한번 인증된 사용자의 정보는 계속 유지되는 WebSocket 세션 객체에 저장

### 3. 공유되는 스레드와 ThreadLocal로 인한 문제

SecurityContextHolder는 ThreadLocal이라는 기술을 사용함

- ThreadLocal: 각 스레드마다 독립된 저장 공간을 제공하는 기술

- HTTP 환경: 요청 1개당 스레드 1개가 할당되므로 안전

- WebSocket 환경: 적은 수의 스레드 풀(Thread Pool)을 여러 사용자가 공유하므로 위험

### 문제 발생

- 스레드 풀의 특정 스레드가 A 유저의 요청을 처리한 후, 해당 스레드에 남아있던 A 유저의 정보가 지워지지 않은 채로 B 유저의 요청을 처리하게 됨

- 결과적으로 '사용자 뒤섞임' 현상이 발생하는 심각한 동시성 이슈 발생

### 해결 방안

- SecurityContextHolder와 같은 스레드 단위의 저장소를 사용하지 않음

- 대신, 스프링이 제공하는 Principal 객체를 컨트롤러 메서드에서 직접 파라미터로 받아 사용

- Principal은 스레드가 아닌, 메시지를 보낸 WebSocket 세션 자체를 기준으로 사용자 정보를 가져오므로 동시성 문제로부터 안전