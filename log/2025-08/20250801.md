## `session_state`

Streamlit은 **“선언형 UI”**\
→ 사용자가 버튼을 누르거나 데이터를 입력하면 **전체 코드가 위에서부터 다시 실행**

```python
count = 0
if st.button("증가"):
    count += 1
st.write(count)
```

이 코드에선 버튼 누를 때마다 `count = 0`부터 다시 시작돼서 항상 `1`만 출력

> 즉, **값이 유지되지 않음**

## `st.session_state`란?

Streamlit에서 **사용자 세션마다 데이터를 “기억”하게 해주는 전역 저장소**

```python
st.session_state["my_key"] = some_value
```

* **세션 단위**: 각 사용자 브라우저 별로 독립적으로 유지됨
* **페이지 새로고침**에도 살아 있음 (단, 브라우저 종료 시 사라짐)
* **딕셔너리처럼 사용** (`dict` 구조)

```python
# 1. 값이 없으면 초기화
if "count" not in st.session_state:
    st.session_state["count"] = 0

# 2. 값 조작
if st.button("증가"):
    st.session_state["count"] += 1

# 3. UI에 출력
st.write("세션 카운트:", st.session_state["count"])
```

### 🔁 Streamlit의 전체 재실행 특성 대응

```python
if "messages" not in st.session_state:
    st.session_state["messages"] = [{"role": "system", "content": system_instruction}]
```

매번 녹음할 때마다 LLM에게 이전 대화까지 함께 보내야 하므로 **대화 내역 유지** 필요
→ `session_state["messages"]`로 유지

### 초기화 버튼

```python
if st.button("초기화"):
    st.session_state["messages"] = [{"role": "system", "content": system_instruction}]
    st.session_state["check_reset"] = True
```

→ 사용자가 버튼 누르면 기존 대화 기록만 초기화하고, 새로 시작

### 전역 변수 방식

```python
count = 0
if st.button("증가"):
    count += 1
st.write(count)  # 항상 1 출력
```

### session\_state 방식

```python
if "count" not in st.session_state:
    st.session_state["count"] = 0
if st.button("증가"):
    st.session_state["count"] += 1
st.write(st.session_state["count"])
```
