
### **1. CS 기본**

#### **1. 프로그램이 동작하기 위한 가장 중요한 컴퓨터의 물리적 자원 3가지**

프로그램이 동작하기 위한 필수 물리적 자원 3가지는 CPU, 메모리(RAM), 저장 디스크(Storage)입니다.

  * **CPU (Central Processing Unit)**: 중앙 처리 장치로, 프로그램의 모든 **계산과 명령어 실행**을 담당하는 컴퓨터의 핵심 두뇌 역할을 합니다.
  * **메모리 (RAM, Random Access Memory)**: CPU가 처리할 데이터를 **임시로 저장**하는 고속 작업 공간입니다. 프로그램이 실행되기 위해서는 해당 코드와 데이터가 메모리에 적재(Load)되어야 합니다.
  * **저장 디스크 (Storage, SSD/HDD)**: 실행 파일이나 데이터를 **영구적으로 보관**하는 비휘발성 저장 공간입니다.



#### **2. 운영체제(OS)의 역할**

운영체제는 **컴퓨터의 하드웨어 자원을 효율적으로 관리**하고, 사용자가 컴퓨터를 편리하게 사용할 수 있도록 **인터페이스를 제공하는 시스템 소프트웨어**입니다. 주요 역할은 다음과 같습니다.

  * **자원 관리 (Resource Management)**: CPU 스케줄링, 메모리 할당, 저장 공간 관리 등 한정된 시스템 자원을 여러 프로세스에 효율적으로 분배하고 관리합니다.
  * **프로세스 관리 (Process Management)**: 프로그램의 실행 단위인 프로세스를 생성 및 삭제하고, 프로세스 간의 동작 순서 제어 및 통신을 관리합니다.
  * **사용자 인터페이스 제공 (User Interface)**: 사용자가 시스템과 상호작용할 수 있는 GUI(그래픽 기반) 또는 CLI(명령어 기반) 환경을 제공합니다.



#### **3. 프로세스와 스레드의 개념 및 차이점**

  * **프로세스 (Process)**: **실행 중인 프로그램**의 인스턴스로, 운영체제로부터 **독립된 메모리 영역(코드, 데이터, 힙, 스택)을 할당**받습니다.
  * **스레드 (Thread)**: **프로세스 내에서 실행되는 작업의 흐름 단위**로, 프로세스가 할당받은 **메모리 영역(코드, 데이터, 힙)을 다른 스레드와 공유**합니다. 단, 스택 영역은 각 스레드마다 독립적으로 할당됩니다.

| 구분 | 프로세스 (Process) | 스레드 (Thread) |
| :--- | :--- | :--- |
| **메모리** | 독립된 메모리 영역 할당 | 스택을 제외한 메모리 영역 공유 |
| **자원 공유**| IPC를 통한 통신 (오버헤드 큼) | 메모리 직접 공유 (오버헤드 작음) |
| **안정성** | 한 프로세스의 장애가 다른 프로세스에 영향을 주지 않음 | 한 스레드의 장애가 전체 프로세스의 동작에 영향을 줄 수 있음 |



#### **4. 멀티스레드 환경의 주요 문제점과 해결 방안**

  * **경쟁 조건 (Race Condition)**: **여러 스레드가 하나의 공유 자원에 동시에 접근**하여 수정하려 할 때, 접근 순서에 따라 실행 결과가 달라지는 문제입니다.

      * **해결 방안**: 한 스레드가 공유 자원을 사용하는 동안 다른 스레드의 접근을 막는 **동기화(Synchronization)** 기법을 사용합니다. 대표적으로 뮤텍스(Mutex)나 세마포어(Semaphore)가 있습니다.

  * **교착 상태 (Deadlock)**: **두 개 이상의 스레드가 서로 상대방의 자원이 해제되기만을 기다리며, 작업을 진행하지 못하는 무한 대기 상태**에 빠지는 문제입니다.

      * **해결 방안**: 교착 상태 발생 조건(상호 배제, 점유와 대기, 비선점, 원형 대기) 중 하나를 제거하여 예방하거나 회피할 수 있습니다. 예를 들어, 모든 스레드가 자원을 획득하는 순서를 동일하게 강제하는 방법이 있습니다.



#### **5. 동기(Synchronous)와 비동기(Asynchronous)**

  * **동기 (Synchronous)**: 요청을 보낸 스레드가 해당 **요청의 결과가 반환될 때까지 대기**한 후 다음 작업을 수행하는 방식입니다. 이 대기 시간 동안 제어권이 막히므로 **블로킹(Blocking)** 연산이라고도 합니다.
  * **비동기 (Asynchronous)**: 요청을 보낸 스레드가 **결과 반환 여부와 관계없이 즉시 다음 작업을 수행**하는 방식입니다. 요청에 대한 결과는 별도의 콜백 함수나 이벤트를 통해 나중에 전달받습니다. 대기 시간이 없어 논블로킹(Non-Blocking)으로 동작합니다.



### **2. Java 기초**

#### **1. 기본 데이터 타입과 참조 데이터 타입의 차이점**

| 구분 | 기본 데이터 타입 (Primitive Data Types) | 참조 데이터 타입 (Reference Data Types) |
| :--- | :--- | :--- |
| **저장 방식** | 변수 공간에 **실제 값(value)을 직접 저장** | 실제 객체는 힙(Heap) 영역에 생성되고, 변수에는 해당 객체를 가리키는 **메모리 주소(reference)를 저장** |
| **메모리 영역** | 주로 **스택(Stack)** 영역에 할당 | 객체 본체는 **힙(Heap)**, 주소값은 스택(Stack)에 할당 |
| **기본값** | `int 0`, `boolean false` 등 타입별 기본값 존재 | `null` |
| **예시** | `int`, `double`, `char`, `boolean` 등 8가지 | `String`, `Array`, 클래스로 생성한 모든 객체 |



#### **2. 오버로딩(Overloading)과 오버라이딩(Overriding)**

  * **오버로딩 (Overloading)**: **하나의 클래스 내에서** 동일한 이름의 메소드를 여러 개 정의하는 기법입니다. 단, **메소드의 파라미터 개수나 타입이 달라야** 합니다.
  * **오버라이딩 (Overriding)**: **상속 관계**에 있는 자식 클래스가 부모 클래스로부터 물려받은 메소드를 **동일한 시그니처(이름, 파라미터, 반환 타입)로 재정의**하는 것입니다.



#### **3. Java 생성자의 목적과 호출 방식**

  * **주요 목적**: `new` 연산자로 객체를 생성할 때, 해당 객체의 **멤버 변수(필드)를 원하는 값으로 초기화**하는 역할을 수행합니다.
  * **호출 방식**: `new` 키워드를 통해 클래스의 인스턴스를 생성하는 시점에 **자동으로 호출**됩니다.



#### **4. Java의 접근 제어자**

  * `public`: **모든 곳에서 접근**이 가능합니다.
  * `protected`: **동일 패키지**에 있거나, **다른 패키지의 자식 클래스**에서 접근이 가능합니다.
  * `default` (package-private): 아무것도 명시하지 않은 상태로, **동일 패키지 내에서만 접근**이 가능합니다.
  * `private`: **오직 해당 클래스 내부에서만 접근**이 가능합니다.



#### **5. 배열(Array)과 연결 리스트(LinkedList)의 차이점**

| 구분 | 배열 (Array) | 연결 리스트 (LinkedList) |
| :--- | :--- | :--- |
| **메모리 구조** | 데이터가 **연속적인** 메모리 공간에 할당 | 데이터(노드)가 **비연속적**으로 할당되고, 각 노드가 다음 노드의 주소를 가리키는 포인터로 연결 |
| **데이터 접근** | **빠름 (O(1))**. 인덱스를 통해 직접 접근 가능 | **느림 (O(n))**. 첫 노드부터 순차적으로 탐색해야 함 |
| **데이터 추가/삭제** | **느림**. 중간 데이터 삽입/삭제 시, 이후 요소들을 이동시켜야 함 | **빠름**. 해당 노드의 포인터만 변경하면 됨 |



#### **6. 예외 처리(Exception Handling) 메커니즘**

  * **try-catch-finally 블록 역할**
      * `try`: **예외 발생 가능성이 있는 코드**를 포함하는 블록.
      * `catch`: `try` 블록에서 **특정 예외가 발생했을 때 이를 처리**하는 코드를 담는 블록.
      * `finally`: 예외 발생 여부와 관계없이 **항상 실행**이 보장되는 블록. 주로 리소스 해제 코드가 위치.
  * **Checked vs Unchecked Exception**
      * **Checked Exception**: **컴파일 시점**에 예외 처리 여부를 강제하는 예외. 반드시 `try-catch` 또는 `throws`로 처리해야 합니다. (예: `IOException`, `SQLException`)
      * **Unchecked Exception**: 실행 시점(Runtime)에 발생하는 예외로, 컴파일러가 처리 여부를 확인하지 않습니다. (예: `NullPointerException`, `ArrayIndexOutOfBoundsException`)



#### **7. Java의 특징 및 JVM 실행 과정**

  * **Java의 가장 큰 특징**: 플랫폼 독립성(Platform Independence)입니다. "한 번 작성하면, 어디서든 실행된다(Write Once, Run Anywhere)"는 슬로건이 이를 상징하며, **객체 지향 프로그래밍(OOP)** 또한 핵심 특징입니다.
  * **JVM (Java Virtual Machine)**: 자바 바이트 코드를 OS에 독립적으로 실행시키는 가상 머신입니다.
  * **실행 과정**:
    1.  **컴파일**: `javac` 컴파일러가 자바 소스 코드(`.java`)를 자바 바이트 코드(`.class`)로 변환합니다.
    2.  **로딩**: JVM의 클래스 로더(Class Loader)가 바이트 코드를 메모리에 적재합니다.
    3.  **실행**: 실행 엔진(Execution Engine)이 바이트 코드를 해석(인터프리터) 및 기계어로 변환(JIT 컴파일러)하여 실행합니다.
  * **메모리 관리**: JVM은 **Runtime Data Area**라는 메모리 영역을 용도에 따라 **Method Area, Heap Area, Stack Area** 등으로 나누어 관리합니다. 특히 **Heap Area**는 객체가 저장되는 공간으로, 가비지 컬렉터(GC)가 사용하지 않는 객체를 자동으로 제거하여 메모리를 관리합니다.



### **3. OOP (객체 지향 프로그래밍)**

#### **1. 클래스, 객체, 인스턴스**

  * **클래스 (Class)**: 객체를 생성하기 위한 **설계도 또는 템플릿**. 객체가 가질 속성(필드)과 행위(메소드)를 정의합니다.
  * **객체 (Object)**: 클래스에 정의된 내용을 바탕으로 **메모리에 실체화된 대상**.
  * **인스턴스 (Instance)**: 클래스로부터 객체를 생성하는 과정을 '인스턴스화'라고 하며, **메모리에 할당된 객체 하나하나**를 해당 클래스의 '인스턴스'라고 부릅니다. 객체와 인스턴스는 종종 같은 의미로 사용됩니다.



#### **2. 캡슐화(Encapsulation)**

  * **개념**: 객체의 데이터(필드)와 그 데이터를 다루는 메소드를 하나로 묶고, **외부에서 데이터에 직접 접근하는 것을 제한하는 원칙**입니다. 정보 은닉(Information Hiding)을 통해 객체의 무결성을 보장하며, 외부에는 허용된 메소드(getter/setter)만을 공개합니다.
  * **구현 예시**:
    ```java
    public class Member {
        private String id; // private으로 외부 직접 접근 차단
        private int age;

        public String getId() { // public getter로 값 조회만 허용
            return id;
        }

        public void setAge(int age) { // public setter로 값 변경을 허용하되,
            if (age > 0) {            // 유효성 검사를 통해 데이터 무결성 유지
                this.age = age;
            }
        }
    }
    ```



#### **3. 인터페이스(Interface)와 추상 클래스(Abstract Class)의 차이점**

| 구분 | 추상 클래스 (Abstract Class) | 인터페이스 (Interface) |
| :--- | :--- | :--- |
| **목적** | **'is a' 관계**. 연관된 클래스들의 **공통된 속성/기능을 추출**하여 상속 | **'can do' 관계**. 클래스가 "수행할 수 있는" 기능의 명세(규약)를 정의 |
| **다중 상속** | **불가능** (클래스 상속은 단일 상속만 허용) | **가능** (여러 인터페이스를 구현할 수 있음) |
| **멤버 구성**| 일반 필드/메소드, 추상 메소드 모두 포함 가능 | 추상 메소드가 원칙 (Java 8부터 `static`, `default` 메소드 허용) |
| **활용 상황**| **공통된 상태(필드)를 공유**하고, 일부 구현을 공유해야 할 때. (예: `Animal` 클래스) | 클래스의 종류와 무관하게 **특정 기능을 부여**하고 싶을 때. (예: `Flyable`, `Serializable` 인터페이스) |



### **4. Database**

#### **1. INNER JOIN과 LEFT JOIN의 비교**

  * **INNER JOIN**: 두 테이블 간에 **조인 조건이 일치하는 행들만** 결과에 포함합니다. 즉, 두 테이블의 **교집합**에 해당하는 데이터를 반환합니다.
  * **LEFT JOIN (LEFT OUTER JOIN)**: **왼쪽 테이블(FROM 절에 먼저 명시된 테이블)의 모든 행을 기준**으로, 오른쪽 테이블에서 조인 조건에 일치하는 데이터를 결합합니다. 오른쪽 테이블에 일치하는 데이터가 없을 경우 해당 컬럼들은 **NULL**로 표시됩니다.



#### **2. WHERE 절과 HAVING 절의 차이점**

가장 큰 차이점은 **실행 순서**입니다. `WHERE`는 **그룹화 전**, `HAVING`은 **그룹화 후**에 적용됩니다.

  * **WHERE 절**:
      * **역할**: `FROM` 절로 가져온 테이블의 **개별 행(raw data)을 필터링**합니다.
      * **예시**: `SELECT * FROM employees WHERE department = 'Sales';`
  * **HAVING 절**:
      * **역할**: **`GROUP BY`로 집계된 그룹 결과**를 필터링합니다. `SUM()`, `COUNT()` 등 **집계 함수에 대한 조건**을 걸 때 사용합니다.
      * **예시**: `SELECT department, AVG(salary) FROM employees GROUP BY department HAVING AVG(salary) >= 5000;`



#### **3. 트랜잭션(Transaction)**

  * **개념**: 데이터베이스의 상태를 변화시키기 위해 수행되는 **하나의 논리적인 작업 단위**입니다. 여러 SQL문이 하나의 트랜잭션으로 묶일 수 있으며, 모두 성공(Commit)하거나 모두 실패(Rollback)하는 'All or Nothing' 원칙을 따릅니다.
  * **특성 (ACID)**: 데이터 무결성을 보장하기 위해 다음 4가지 특성을 가집니다.
      * **원자성 (Atomicity)**: 트랜잭션의 모든 연산은 완전히 수행되거나 전혀 수행되지 않아야 합니다.
      * **일관성 (Consistency)**: 트랜잭션이 성공적으로 완료되면 데이터베이스는 항상 일관된 상태를 유지해야 합니다.
      * **고립성 (Isolation)**: 하나의 트랜잭션이 실행되는 동안 다른 트랜잭션의 영향을 받지 않아야 합니다.
      * **지속성 (Durability)**: 성공적으로 완료된 트랜잭션의 결과는 영구적으로 저장되어야 합니다.



#### **4. DB의 Index**

  * **개념**: 데이터베이스 테이블의 **검색(SELECT) 속도를 향상시키기 위한 자료구조**입니다. 책의 '찾아보기'처럼, 인덱스는 데이터의 위치 정보를 저장하여 Full-Scan을 피하고 빠르게 원하는 데이터에 접근할 수 있도록 돕습니다.
  * **장점**: `WHERE` 절이나 `JOIN` 조건에 사용되는 컬럼에 적용 시 **조회 성능을 크게 향상**시킬 수 있습니다.
  * **단점**: 데이터의 **삽입, 수정, 삭제(CUD) 시 인덱스도 함께 업데이트**되어야 하므로 CUD 성능은 저하될 수 있으며, 인덱스를 위한 **별도의 저장 공간**이 필요합니다.



### **5. Spring**

#### **1. 의존성 주입(DI)의 3가지 방법**

1.  **생성자 주입 (Constructor Injection)**: **가장 권장되는 방식**입니다. 생성자를 통해 의존성을 주입하며, 객체 생성 시점에 모든 의존 관계가 확정되므로 **불변성(Immutability)을 보장**하고 **NPE(NullPointerException)를 방지**할 수 있습니다.
2.  **세터 주입 (Setter Injection)**: `setter` 메소드를 통해 의존성을 주입합니다. 객체 생성 이후에도 의존성을 변경할 수 있어 유연하지만, 외부에 노출되어 변경 가능성이 열려있다는 단점이 있습니다. **선택적인 의존성**을 주입할 때 사용됩니다.
3.  **필드 주입 (Field Injection)**: `@Autowired`를 필드에 직접 선언하는 방식입니다. 코드가 간결하지만 외부에서 제어가 불가능하여 **단위 테스트가 어렵고**, 의존 관계가 숨겨지는 등 단점이 많아 **사용을 권장하지 않습니다.**



#### **2. 스프링 빈(Bean)**

  * **개념**: **Spring IoC 컨테이너가 생성하고 관리하는 자바 객체**입니다. 개발자가 직접 객체를 생성하고 관리하는 대신, Spring 컨테이너가 객체의 생성, 생명주기 관리, 의존성 주입 등을 담당하는데, 이 관리 대상을 '빈'이라고 합니다.
  * **등록 방법**:
      * **컴포넌트 스캔 (Component Scanning)**: `@Component`, `@Service`, `@Controller`, `@Repository` 등의 어노테이션을 클래스에 붙여두면 Spring이 자동으로 스캔하여 빈으로 등록합니다.
      * **자바 설정 클래스를 통한 등록**: `@Configuration`이 적용된 클래스 내에서 `@Bean` 어노테이션을 사용한 메소드를 통해 직접 객체를 생성하고 반환하여 빈으로 등록할 수 있습니다.



#### **3. IoC(제어의 역전)와 DI(의존성 주입)**

  * **IoC (Inversion of Control)**: 객체의 생성, 관리, 의존 관계 설정 등 **객체에 대한 제어권이 개발자에게서 Spring 프레임워크(IoC 컨테이너)로 넘어간 것**을 의미합니다.
  * **DI (Dependency Injection)**: **IoC를 구현하기 위한 핵심 메커니즘**입니다. 클래스가 필요로 하는 의존 객체를 직접 생성하지 않고, **외부(IoC 컨테이너)에서 생성하여 주입**해주는 방식입니다.
  * **사용 이유**: 객체 간의 **결합도를 낮추고(느슨한 결합, Loose Coupling)** 유연성과 확장성을 높이기 위함입니다. 이를 통해 모듈화가 용이해지고, 단위 테스트가 쉬워지며, 코드의 유지보수성이 크게 향상됩니다.



### **6. JDBC**

#### **1. JDBC(Java Database Connectivity)란?**

자바 애플리케이션이 데이터베이스에 연결하고 데이터를 조작할 수 있도록 해주는 자바 표준 API(인터페이스)입니다. 각 DB 벤더(Oracle, MySQL 등)는 JDBC 인터페이스를 구현한 드라이버(Driver)를 제공하며, 개발자는 이 드라이버를 통해 DB 종류에 상관없이 일관된 방식으로 데이터베이스에 접근할 수 있습니다.



#### **2. JDBC 주요 객체의 역할**

  * **Connection**: 자바 애플리케이션과 데이터베이스 간의 연결(세션)을 나타내는 객체입니다.
  * **Statement**: 생성된 연결을 통해 **SQL 쿼리문을 데이터베이스로 전송하고 실행**하는 역할을 합니다. (`PreparedStatement`는 SQL Injection 공격을 방지하고 성능이 우수하여 주로 사용됩니다.)
  * **ResultSet**: `SELECT` 쿼리의 실행 **결과로 반환된 데이터의 집합**을 담는 객체입니다. 이 객체를 통해 결과를 순회하며 데이터를 추출할 수 있습니다.



### **7. JPA**

#### **1. ORM(Object-Relational Mapping)의 역할**

**객체(Object)와 관계형 데이터베이스(Relational Database)의 데이터를 자동으로 매핑(Mapping)해주는 기술**입니다. 개발자는 SQL 쿼리를 직접 작성하는 대신 자바 객체를 다루는 방식으로 프로그래밍할 수 있으며, ORM 프레임워크가 적절한 SQL을 생성하여 실행해 줍니다. 이를 통해 SQL 종속적인 개발에서 벗어나 생산성을 향상시킬 수 있습니다.



#### **2. 영속성 컨텍스트(Persistence Context)와 엔티티 생명 주기**

  * **영속성 컨텍스트**: **엔티티를 영구 저장하는 환경**으로, 엔티티 매니저에 의해 생성되고 관리되는 논리적인 공간입니다. JPA는 이 컨텍스트를 통해 **1차 캐시, 쓰기 지연(Transactional write-behind), 변경 감지(Dirty Checking), 지연 로딩(Lazy Loading)** 등의 기능을 제공합니다.
  * **엔티티 생명 주기**:
    1.  **비영속 (New/Transient)**: 영속성 컨텍스트와 관계없이 `new`로만 생성된 상태.
    2.  **영속 (Managed)**: `EntityManager.persist()` 등으로 영속성 컨텍스트에 의해 관리되는 상태.
    3.  **준영속 (Detached)**: 영속성 컨텍스트가 관리하다가 분리된 상태.
    4.  **삭제 (Removed)**: DB에서 삭제하기로 한 상태.



#### **3. JPA의 N+1 문제와 해결 전략**

  * **N+1 문제**: 연관 관계가 설정된 엔티티를 조회할 때, **첫 쿼리(1)의 결과로 N개의 데이터가 조회**되고, 이 N개의 데이터를 **루프 돌면서 연관된 데이터를 조회하기 위해 N개의 추가 쿼리가 발생하는 현상**입니다.
  * **발생 원인**: 주로 JPQL 조회 시 연관된 엔티티를 지연 로딩(Lazy Loading)으로 설정했을 때, 해당 엔티티를 실제로 사용하는 시점에 추가 쿼리가 발생하여 나타납니다.
  * **해결 전략**:
      * **페치 조인 (Fetch Join)**: JPQL에서 `JOIN FETCH`를 사용하여 처음부터 연관된 엔티티까지 하나의 SQL로 함께 조회하는 가장 일반적인 해결책입니다.
      * **@EntityGraph**: 어노테이션을 통해 특정 조회 시에 함께 가져올 엔티티를 동적으로 지정하는 방식입니다.
      * **배치 사이즈 조절 (Batch Size)**: `@BatchSize` 또는 yml 설정을 통해, 지연 로딩 시 N개의 추가 쿼리를 `IN` 절을 사용하는 하나의 쿼리로 묶어서 실행하여 쿼리 수를 줄입니다.



### **8. Web & Network**

#### **1. IP와 Port의 역할**

  * **IP 주소 (IP Address)**: 인터넷에 연결된 **컴퓨터(호스트)를 식별하기 위한 고유한 주소**입니다. 네트워크 상에서 통신의 대상을 지정하는 역할을 합니다.
  * **포트 번호 (Port Number)**: IP 주소를 통해 컴퓨터에 도달한 후, **특정 애플리케이션(프로세스)을 식별하기 위한 번호**입니다. 하나의 컴퓨터에서 실행되는 여러 프로그램 중 어떤 프로그램과 통신할지를 지정합니다.

> 즉, **IP는 목적지 컴퓨터를, 포트는 해당 컴퓨터 내의 목적지 프로그램을 찾아가는 역할**을 합니다.



#### **2. 쿠키(Cookie)와 세션(Session)의 차이**

| 구분 | 쿠키 (Cookie) | 세션 (Session) |
| :--- | :--- | :--- |
| **저장 위치** | **클라이언트 (브라우저)** | **서버** |
| **보안** | 클라이언트에 저장되어 변조나 탈취에 상대적으로 **취약** | 서버에 중요 정보를 저장하고 클라이언트에는 식별자(Session ID)만 전달하므로 상대적으로 **안전** |
| **생명 주기** | 설정된 만료 기간까지 유지 가능 | 브라우저 종료 시 삭제되는 것이 일반적 |
| **용량 및 데이터**| 문자열만 저장 가능, 용량 제한 작음(약 4KB) | 객체 등 모든 타입 저장 가능, 용량 제한 거의 없음 |



#### **3. 웹 브라우저 주소창에 URL 입력 후 일어나는 일**

1.  **DNS 조회**: 브라우저는 `www.google.com`과 같은 도메인 네임을 실제 서버의 **IP 주소로 변환**하기 위해 DNS 서버에 쿼리를 보냅니다. (로컬 캐시를 먼저 확인합니다.)
2.  **TCP 연결 수립**: DNS로부터 획득한 IP 주소를 사용하여 목적지 서버와 **TCP 3-Way Handshake** 과정을 통해 신뢰성 있는 연결을 수립합니다.
3.  **HTTP(S) 요청**: 브라우저는 서버에 전송할 **HTTP 요청 메시지**를 생성하여 TCP 소켓을 통해 전송합니다. HTTPS의 경우, 전송 전에 **SSL/TLS Handshake**를 통해 통신을 암호화합니다.
4.  **서버 처리 및 응답**: 서버는 요청을 해석하고, 그에 맞는 처리 후 결과를 담은 **HTTP 응답 메시지**(HTML, CSS, JS 파일 등)를 생성하여 브라우저에 전송합니다.
5.  **브라우저 렌더링**: 브라우저는 서버로부터 받은 응답(주로 HTML)을 파싱하여 **DOM(Document Object Model) 트리를 구축**하고, CSS를 파싱하여 **CSSOM 트리를 구축**합니다. 이 둘을 결합하여 **렌더 트리**를 만든 후, 화면에 콘텐츠를 배치(Layout)하고 그리는(Paint) 과정을 거쳐 사용자에게 웹 페이지를 보여줍니다.