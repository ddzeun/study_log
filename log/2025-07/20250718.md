## useEffect vs useRef

### `useEffect` : 컴포넌트가 화면에 그려진 후에, 이 일을 실행해줘

- 역할: 사이드 이펙트(Side Effect)를 처리하기 위한 훅
(사이드 이펙트란, 컴포넌트가 화면을 그리는(렌더링) 주된 임무 외에 하는 모든 부수적인 작업)
    - 예시: 서버에 데이터 요청(API 호출), 웹소켓 연결 설정, 타이머 설정 등
- 실행 시점: 이름 그대로, 렌더링이라는 이펙트(Effect)가 끝난 후(use)에 실행. React가 UI를 다 그리고 나서, "자, 이제 부수적인 작업들을 시작해볼까?" 하고 `useEffect` 안의 코드를 실행
- 정리(Cleanup) 기능: `useEffect` 안에서 `return` 하는 함수는, 이 컴포넌트가 화면에서 사라지거나, `useEffect`가 다시 실행되기 직전에 호출. 웹소켓 연결을 끊는(`deactivate`) 것처럼, 시작했던 일을 '정리'하는 데 유용

### `useRef` : 리렌더링과 상관없이, 이 값을 계속 기억해줘

- 역할: 컴포넌트의 전체 생명주기 동안 계속 유지되는 '저장 공간'을 제공
- 가장 중요한 특징 (useState와의 차이점):
    1. `useRef`에 저장된 값(`clientRef.current`)을 변경해도, 컴포넌트가 절대 리렌더링되지 않음
    2. 컴포넌트가 리렌더링 되어도, `useRef`에 저장된 값은 초기화되지 않고 그대로 유지. (일반 변수 `let` 이나 `const`는 리렌더링될 때마다 초기화)

### 그래서 채팅 기능 구현 시 둘 다 필요!

1. 우리는 단 하나의 `stompClient` 객체를 만들어서, 컴포넌트가 리렌더링 되어도 계속 그 객체를 사용해야함. 만약 일반 변수에 만들면 리렌더링될 때마다 새로운 연결을 시도해야하기 때문에 값을 계속 기억하기 위해 `useRef`가 필요
2. `stompClient` 객체의 상태가 바뀐다고 해서 화면 전체가 깜빡일(리렌더링) 필요 없이 화면 뒤에서 조용히 일어나야 하는 일. 만약 `useState`에 저장하면 불필요한 리렌더링이 발생하기 때문에 리렌더링을 막기 위해 `useRef`가 필요해요.
3. 웹소켓 연결을 시작(`activate`)하고 구독(`subscribe`)하는 작업은, 컴포넌트가 화면에 처음 그려진 '후에'딱 한 번만 일어나야 하는 '부수적인 작업'이기 때문에 이 모든 연결 로직을 `useEffect` 안에 작성


- `useEffect`: 언제(When) 실행할지, 즉 '타이밍'을 관리 (컴포넌트가 그려진 후에 연결하고, 사라지기 전에 연결을 끊는다)
- `useRef`: 무엇을(What) 저장할지, 즉 '기억'을 관리 (리렌더링과 상관없이 `stompClient` 객체 하나를 계속 기억한다)
